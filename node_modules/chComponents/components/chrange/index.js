'use strict';

import impTemplate from './template.js';
import dom from '../../dom.js';

const { template, elInput, elHandle } = impTemplate;

class chRange extends HTMLElement {
    constructor() {
        super();
        this.root = this.attachShadow({
            mode: 'closed'
        })
        this.root.append(template.cloneNode(true));

        // Objekt, um Elemente in dieser Component zwischenzuspeichern
        this.elements = {};
        this.domMapping();
    }


    // Componente rendern
    domMapping() {
        this.elements.input = this.root.querySelector('input[type="text"]');
        // this.elements.range = this.root.querySelector('input[type="range"]');
        this.elements.railRange = this.root.querySelector('.railRange');
        this.elements.btnClear = this.root.querySelector('.btnClear');
        this.elements.container = this.root.querySelector('.container');
        this.elements.parentInput = this.root.querySelector('.wrapperInput');
        this.elements.parentRange = this.root.querySelector('.parentRange');
    }


    // Nicht-String-Atribute übergeben
    update({
        value = null,
        values = [],
        min = 0,
        max = 1,
        step = .1,
        bgColor = null,
        // width = null,
        fontSize = null,
        width = 300,
    } = {}) {

        if (value != null) this.elements.input.value = value;
        this.elements.parentRange.style.width = `${width}px`;

        if (bgColor != null) this.elements.container.style['background-color'] = bgColor;

        if (fontSize != null) {
            this.elements.input.style['fontSize'] = fontSize + 'px';
            this.elements.input.style['padding'] = fontSize / 3 + 'px';
        }

        if (values.length) {
            values.forEach((value, index) => {

                let valPos = width / (max - min) * value;

                let elHandleByVal = elHandle.cloneNode(true);
                elHandleByVal.style.left = valPos + 'px';
                this.elements.railRange.append(elHandleByVal);

                let elInputByValue = elInput.cloneNode(true);
                elInputByValue.style.width = '70px';
                elInputByValue.value = value;
                this.elements.parentInput.append(elInputByValue);

                let oldValue = value;

                // Sondertasten
                elInputByValue.addEventListener('keyup', evt => {
                    // Punkte statt Komma
                    evt.target.value = evt.target.value.replaceAll(',', '.');

                    // Falsche Tasten Eingabe
                    if (isNaN(evt.target.value))
                        evt.target.value = oldValue;

                    // Pfeiltasten
                    if (evt.key == 'ArrowUp') {
                        if (evt.shiftKey) {
                            value = Math.round(+evt.target.value + (max - min) / 10);
                        } else {
                            value = +evt.target.value + 1;
                        }
                        value = Math.min(value, max);
                    } else if (evt.key == 'ArrowDown') {
                        if (evt.shiftKey) {
                            value = Math.round(+evt.target.value - (max - min) / 10);
                        } else {
                            value = +evt.target.value - 1;
                        }
                        value = Math.max(value, min);
                    }
                    evt.target.value = value;

                    oldValue = evt.target.value;

                    let valPos = width / (max - min) * value;
                    elHandleByVal.style.left = valPos + 'px';
                    elInputByValue.value = value;

                })

                elInputByValue.addEventListener('change', evt => {
                    // Daten aktualisieren
                    let value = evt.target.value;
                    value = Math.max(value, min);
                    value = Math.min(value, max);
                    values[index] = value;
                })

                

            })
        }
    }


    // Eventlistener für Mounting
    connectedCallback() {
        // Text-Eingabe
        /*
        this.elements.input.addEventListener('input', evt => {
            this.elements.range.value = this.elements.input.value;
            const myEvent = new CustomEvent('input', {
                detail: {
                    event: evt,
                    type: 'input',
                    value: this.elements.input.value,
                    key: evt.data
                }
            })
            this.dispatchEvent(myEvent);
        })

        this.elements.input.addEventListener('change', evt => {
            this.elements.range.value = this.elements.input.value;
            const myEvent = new CustomEvent('change', {
                detail: {
                    event: evt,
                    type: 'change',
                    value: this.elements.input.value,
                    key: evt.data
                }
            })
            this.dispatchEvent(myEvent);
        })

        this.elements.input.addEventListener('focus', evt => {
            const myEvent = new CustomEvent('focus', {
                detail: {
                    event: evt,
                    type: 'focus',
                    value: this.elements.input.value,
                }
            })
            this.dispatchEvent(myEvent);
        })

        this.elements.input.addEventListener('blur', evt => {
            const myEvent = new CustomEvent('blur', {
                detail: {
                    event: evt,
                    type: 'blur',
                    value: this.elements.input.value,
                }
            })
            this.dispatchEvent(myEvent);
        })
        */
    }
}

customElements.define('ch-range', chRange);